## 渲染逻辑

### 创建fiber树

解析JSX代码，生成React节点对象，同时创建对应节点的fiber。

#### 为什么不是递归便利？

浏览器上的页面是一帧一帧绘制出来的，页面的刷新率要大于60HZ，人眼才会感觉流畅，也就是说，1秒钟内页面至少刷新60次，每一次的处理时间为16.7ms。在这16.7ms内，浏览器需要完成事件处理、js、布局、渲染等任务。

由于递归无法中断，如果遇到比较复杂的节点树，则需要花费大量时间，以至于长期占用浏览器线程资源，导致浏览器无法在目标时间内完成刷新，从而造成页面的卡顿。

#### 异步可中断

React采用异步可中断的策略(好像是基于`requestAnimationFrame`实现的)，将遍历工作分配到各个帧中处理，保证页面的流畅。

#### render阶段、commit阶段

React不会创建完一个节点(render阶段)，就将其插入到dom当中，而是整个fiber树构建完成后，再将其插入到dom中(commit阶段)。这样做是因为任务被分配到不同帧去处理，如果实时插入的话，导致某些时刻页面上显示不完整的UI。

### Fiber树

![Fiber树](https://github.com/quanshubli/blog/blob/main/images/fibertree.jpg)

每个fiber节点都有child、sibling和parent三个属性，分别指向自己的第一个子节点、第一个兄弟节点和父节点。

这样设计的目的是便于获取下一个任务节点。当前节点处理完成后，首先会查找它的child，如果存在就将其作为下一个任务节点，否则就查找它的sibling，如果没有，就查找它的parent节点的sibling，以此类推。

### Diff

1. 对于相同`type`的节点，仅做属性的修改

2. 对于不同`type`的节点，做删除和新增

## 函数组件

函数组件于类组件的区别在于：

1. 函数组件的fiber不存在dom属性。

2. 类组件的`chilren`存在`props`中，而函数组件的`children`由自身调用返回。
 


